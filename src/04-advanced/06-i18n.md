# Internationalisation (i18n)

WaterUI's plugin system lets you intercept component configuration and swap text before views render.
The official `waterui-i18n` crate builds on this pattern; the example below shows how to construct a
bespoke localiser inside your application code.

## Building a translation store

Create a plugin that stores translations and overrides `TextConfig` via an environment hook.

```rust,ignore
use std::collections::BTreeMap;
use waterui::component::text::{Text, TextConfig};
use waterui::prelude::*;
use waterui::view::Hook;
use waterui_core::extract::{Extractor, Use};

#[derive(Clone, Default)]
struct I18n {
    translations: BTreeMap<Str, BTreeMap<Str, Str>>,
}

impl I18n {
    fn insert(&mut self, locale: impl Into<Str>, key: impl Into<Str>, value: impl Into<Str>) {
        self.translations
            .entry(locale.into())
            .or_default()
            .insert(key.into(), value.into());
    }

    fn resolve(&self, locale: &str, key: &str) -> Option<Str> {
        self.translations.get(locale).and_then(|map| map.get(key).cloned())
    }
}

impl Plugin for I18n {
    fn install(self, env: &mut Environment) {
        env.insert(self);
        env.insert(Hook::new(|env: &Environment, mut config: TextConfig| {
            let locale = env.get::<Locale>().cloned().unwrap_or_else(|| Locale("en".into()));
            let Use(i18n) = Extractor::extract::<Use<I18n>>(env).unwrap();
            config.content = config
                .content
                .map(move |key| i18n.resolve(&locale.0, &key).unwrap_or(key))
                .into_computed();
            Text::from(config)
        }));
    }
}

#[derive(Clone)]
struct Locale(Str);
```

The hook maps the original text content into the locale-specific translation. When no translation is
available it falls back to the key itself, making missing strings obvious during development.

## Using the plugin

Install the plugin and set the current locale in your environment.

```rust,ignore
fn greeting() -> impl View {
    let mut i18n = I18n::default();
    i18n.insert("en", "greeting", "Hello");
    i18n.insert("fr", "greeting", "Bonjour");

    text!("greeting")
        .with(Locale("fr".into()))
        .with(i18n)
}
```

Every `text!` call now passes through the hook. Switching the `Locale` value anywhere in the
environment updates downstream components automatically because the translated text is stored in a
computed signal.

## Dynamic content

You can wrap richer views inside translation lookups by storing formatted strings or by replacing the
entire view tree. For example, use `Dynamic` to select different compositions based on locale and
input data.

```rust,ignore
fn localized_score(score: Binding<u32>) -> impl View {
    Dynamic::watch(score.clone(), move |value| {
        match value {
            0 => AnyView::new(text!("greeting")),
            1..=10 => AnyView::new(text!("{} points", value)),
            _ => AnyView::new(text!("High score!")),
        }
    })
}
```

Pair this with the plugin above so `text!("greeting")` resolves through the translation map while the
numeric branches remain literal.
